<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Michaelis-Menten Kinetics Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #333;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 0 auto;
            background-color: #ffffff;
        }
        
        button {
            padding: 8px 15px;
            margin: 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button.stop {
            background-color: #f44336;
        }
        
        button.stop:hover {
            background-color: #d32f2f;
        }
        
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .stats-table th, .stats-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .stats-table th {
            background-color: #f2f2f2;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
        }
        
        .slider-value {
            margin-left: 10px;
            min-width: 30px;
        }
        
        #dotCount {
            width: 200px;
        }
        
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Michaelis-Menten Kinetics Simulation</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="dotCount">Substrate Concentration (dots):</label>
                <div class="slider-container">
                    <input type="range" id="dotCount" min="10" max="200" value="50">
                    <span id="dotCountValue" class="slider-value">50</span>
                </div>
            </div>
            
            <div class="control-group">
                <button id="startBtn">Start</button>
                <button id="stopBtn" class="stop">Stop</button>
                <button id="resetBtn">Reset</button>
            </div>
        </div>
        
        <canvas id="simulationCanvas" width="800" height="550"></canvas>
        
        <div class="explanation">
            <h3>How Stickiness Works:</h3>
            <p><strong>Stickiness = Catch Probability × Passageway Slowness</strong></p>
            <p>• <strong>High Stickiness (Blue Mitts):</strong> 90% catch rate, but very slow metabolism (3x slower)</p>
            <p>• <strong>Medium Stickiness:</strong> 50% catch rate, moderate metabolism speed</p>
            <p>• <strong>Low Stickiness (Red Mitts):</strong> 10% catch rate, but fast metabolism (3x faster)</p>
            <p>This represents the Michaelis-Menten tradeoff: stronger binding (high stickiness) means better substrate capture at low concentrations but slower catalytic turnover.</p>
        </div>
        
        <table id="statsTable" class="stats-table" style="display: none;">
            <thead>
                <tr>
                    <th>Enzyme Mitt</th>
                    <th>Stickiness</th>
                    <th>Catch Rate</th>
                    <th>Time Survived (s)</th>
                    <th>Dots Metabolized</th>
                </tr>
            </thead>
            <tbody id="statsBody">
                <!-- Stats will be populated here -->
            </tbody>
        </table>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        
        // Control elements
        const dotCountSlider = document.getElementById('dotCount');
        const dotCountValue = document.getElementById('dotCountValue');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const statsTable = document.getElementById('statsTable');
        const statsBody = document.getElementById('statsBody');
        
        // Simulation parameters
        const numMitts = 4;
        const mittWidth = 60;
        const mittHeight = 40;
        const passagewayHeight = 120;
        const cellRadius = 30;
        const dotRadius = 5;
        const topSectionHeight = 150;
        
        // Simulation state
        let dots = [];
        let mitts = [];
        let cells = [];
        let animationId = null;
        let isRunning = false;
        let startTime = null;
        let currentTime = 0;
        
        // Create texture gradient for mitts - more texture for stickier mitts
        function createMittTexture(stickiness) {
            const textureCanvas = document.createElement('canvas');
            textureCanvas.width = 20;
            textureCanvas.height = 20;
            const textureCtx = textureCanvas.getContext('2d');
            
            // Single solid color (no gradient)
            const hue = 240 - (stickiness * 120);
            const saturation = 70 + (stickiness * 30);
            const lightness = 50 - (stickiness * 10);
            
            textureCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            textureCtx.fillRect(0, 0, 20, 20);
            
            // Texture intensity increases with stickiness
            const textureIntensity = Math.floor(stickiness * 8);
            
            if (textureIntensity > 0) {
                textureCtx.strokeStyle = `hsl(${hue}, ${saturation}%, ${lightness - 15}%)`;
                textureCtx.lineWidth = 1;
                
                // Cross-hatch pattern with intensity based on stickiness
                for (let i = 0; i < textureIntensity; i++) {
                    const spacing = 20 / (textureIntensity + 1);
                    
                    // Horizontal lines
                    textureCtx.beginPath();
                    textureCtx.moveTo(0, (i + 1) * spacing);
                    textureCtx.lineTo(20, (i + 1) * spacing);
                    textureCtx.stroke();
                    
                    // Vertical lines
                    textureCtx.beginPath();
                    textureCtx.moveTo((i + 1) * spacing, 0);
                    textureCtx.lineTo((i + 1) * spacing, 20);
                    textureCtx.stroke();
                }
            }
            
            return ctx.createPattern(textureCanvas, 'repeat');
        }
        
        // Initialize the simulation
        function initSimulation() {
            dots = [];
            mitts = [];
            cells = [];
            currentTime = 0;
            
            // Create mitts with EXTREME differences in stickiness (left to right)
            const mittSpacing = (canvas.width - numMitts * mittWidth) / (numMitts + 1);
            for (let i = 0; i < numMitts; i++) {
                const x = mittSpacing + i * (mittWidth + mittSpacing);
                const y = topSectionHeight;
                
                // EXTREME stickiness differences (0.1 to 0.9)
                const stickiness = 0.1 + (i * 0.8 / (numMitts - 1));
                
                mitts.push({
                    x: x,
                    y: y,
                    width: mittWidth,
                    height: mittHeight,
                    stickiness: stickiness,
                    catchProbability: 0.1 + (stickiness * 0.8),
                    passagewaySpeed: 0.02 / (0.5 + stickiness * 0.5),
                    caughtDots: 0,
                    startTime: null,
                    timeSurvived: 0,
                    texture: createMittTexture(stickiness)
                });
                
                // Create corresponding cells beneath each mitt
                cells.push({
                    x: x + mittWidth/2,
                    y: y + mittHeight + passagewayHeight + cellRadius,
                    radius: cellRadius,
                    health: 100,
                    lastFedTime: 0,
                    isAlive: true
                });
            }
            
            // Create initial dots
            createDots(dotCountSlider.value);
            
            // Reset stats table
            statsTable.style.display = 'none';
            statsBody.innerHTML = '';
        }
        
        // Create dots based on current count
        function createDots(count) {
            dots = [];
            for (let i = 0; i < count; i++) {
                dots.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (topSectionHeight - 20) + 10,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    radius: dotRadius,
                    isCaught: false,
                    caughtBy: null,
                    inPassageway: false,
                    passagewayProgress: 0
                });
            }
            
            // Update dot count display in real-time
            dotCountValue.textContent = count;
        }
        
        // Update dot count display - REAL-TIME UPDATES
        dotCountSlider.addEventListener('input', function() {
            const targetCount = parseInt(this.value);
            
            if (!isRunning) {
                // If not running, just update display
                dotCountValue.textContent = targetCount;
                return;
            }
            
            // Real-time updates while running
            const currentCount = dots.length;
            
            if (targetCount > currentCount) {
                // Add more dots
                const dotsToAdd = targetCount - currentCount;
                for (let i = 0; i < dotsToAdd; i++) {
                    dots.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * (topSectionHeight - 20) + 10,
                        vx: (Math.random() - 0.5) * 3,
                        vy: (Math.random() - 0.5) * 3,
                        radius: dotRadius,
                        isCaught: false,
                        caughtBy: null,
                        inPassageway: false,
                        passagewayProgress: 0
                    });
                }
            } else if (targetCount < currentCount) {
                // Remove excess dots (remove uncaptured ones first)
                const dotsToKeep = targetCount;
                const capturedDots = dots.filter(dot => dot.isCaught || dot.inPassageway);
                const freeDots = dots.filter(dot => !dot.isCaught && !dot.inPassageway);
                
                // Keep all captured dots + needed free dots
                dots = capturedDots.concat(freeDots.slice(0, Math.max(0, dotsToKeep - capturedDots.length)));
            }
            
            dotCountValue.textContent = targetCount;
        });
        
        // Start simulation
        startBtn.addEventListener('click', function() {
            if (!isRunning) {
                isRunning = true;
                startTime = Date.now();
                
                mitts.forEach(mitt => {
                    if (mitt.startTime === null) {
                        mitt.startTime = startTime;
                    }
                });
                
                animate();
            }
        });
        
        // Stop simulation
        stopBtn.addEventListener('click', function() {
            if (isRunning) {
                isRunning = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                displayStats();
            }
        });
        
        // Reset simulation
        resetBtn.addEventListener('click', function() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            isRunning = false;
            initSimulation();
            draw();
        });
        
        // Display stats table - FIXED: Properly iterate through mitts
        function displayStats() {
            statsTable.style.display = 'table';
            statsBody.innerHTML = '';
            
            mitts.forEach((mitt, index) => {
                const row = document.createElement('tr');
                
                const mittCell = document.createElement('td');
                mittCell.textContent = `Enzyme ${index + 1}`;
                
                const stickinessCell = document.createElement('td');
                stickinessCell.textContent = mitt.stickiness.toFixed(2);
                
                const catchRateCell = document.createElement('td');
                catchRateCell.textContent = `${(mitt.catchProbability * 100).toFixed(0)}%`;
                
                const timeCell = document.createElement('td');
                if (mitt.startTime) {
                    const timeSurvived = (Date.now() - mitt.startTime) / 1000;
                    timeCell.textContent = timeSurvived.toFixed(2);
                    mitt.timeSurvived = timeSurvived;
                } else {
                    timeCell.textContent = "0.00";
                }
                
                const dotsCell = document.createElement('td');
                dotsCell.textContent = mitt.caughtDots;
                
                row.appendChild(mittCell);
                row.appendChild(stickinessCell);
                row.appendChild(catchRateCell);
                row.appendChild(timeCell);
                row.appendChild(dotsCell);
                
                statsBody.appendChild(row);
            });
        }
        
        // Main animation loop
        function animate() {
            if (!isRunning) return;
            
            currentTime = (Date.now() - startTime) / 1000;
            update();
            draw();
            animationId = requestAnimationFrame(animate);
        }
        
        // Update simulation state - FIXED collision detection
        function update() {
            // Update dots - keep them in top section
            dots.forEach(dot => {
                if (!dot.isCaught && !dot.inPassageway) {
                    dot.x += dot.vx;
                    dot.y += dot.vy;
                    
                    // Boundary checks - FIXED: Don't bounce at mitt boundary
                    if (dot.x < dot.radius || dot.x > canvas.width - dot.radius) {
                        dot.vx = -dot.vx;
                        dot.x = Math.max(dot.radius, Math.min(canvas.width - dot.radius, dot.x));
                    }
                    
                    if (dot.y < dot.radius) {
                        dot.vy = -dot.vy;
                        dot.y = dot.radius;
                    }
                    
                    // IMPORTANT FIX: Only bounce if dot is about to go below mitt AND not touching mitt
                    let isTouchingMitt = false;
                    mitts.forEach((mitt, index) => {
                        // Check if dot is vertically aligned with mitt
                        if (dot.x > mitt.x && dot.x < mitt.x + mitt.width) {
                            // Dot is above mitt and close to mitt boundary
                            if (dot.y + dot.radius > mitt.y - 2 && dot.y < mitt.y + mitt.height) {
                                isTouchingMitt = true;
                            }
                        }
                    });
                    
                    // Only bounce if not touching mitt and about to cross boundary
                    if (dot.y > topSectionHeight - dot.radius && !isTouchingMitt) {
                        dot.vy = -Math.abs(dot.vy);
                        dot.y = topSectionHeight - dot.radius;
                    }
                    
                    // Check if dot is caught by a mitt - IMPROVED detection
                    mitts.forEach((mitt, index) => {
                        if (!dot.isCaught && !dot.inPassageway) {
                            // More generous collision detection
                            const mittCenterX = mitt.x + mitt.width / 2;
                            const mittCenterY = mitt.y + mitt.height / 2;
                            const distanceX = Math.abs(dot.x - mittCenterX);
                            const distanceY = Math.abs(dot.y - mittCenterY);
                            
                            // Check if dot is within mitt bounds
                            if (distanceX < mitt.width / 2 + dot.radius && 
                                distanceY < mitt.height / 2 + dot.radius) {
                                
                                // Random chance based on stickiness
                                if (Math.random() < mitt.catchProbability) {
                                    dot.isCaught = true;
                                    dot.caughtBy = index;
                                    dot.inPassageway = true;
                                    mitt.caughtDots++; // This should now work correctly
                                    
                                    // Position dot at mitt entrance
                                    dot.x = mitt.x + mitt.width / 2;
                                    dot.y = mitt.y + mitt.height;
                                    
                                    if (cells[index].isAlive) {
                                        cells[index].lastFedTime = currentTime;
                                    }
                                    
                                    console.log(`Dot caught by mitt ${index + 1}! Total: ${mitt.caughtDots}`);
                                }
                            }
                        }
                    });
                } else if (dot.inPassageway) {
                    const mittIndex = dot.caughtBy;
                    const mitt = mitts[mittIndex];
                    
                    dot.passagewayProgress += mitt.passagewaySpeed;
                    
                    if (dot.passagewayProgress >= 1) {
                        dot.inPassageway = false;
                        mitt.caughtDots--; // Dot has exited the system
                        dot.x = Math.random() * canvas.width;
                        dot.y = Math.random() * (topSectionHeight - 40) + 20;
                        dot.vx = (Math.random() - 0.5) * 3;
                        dot.vy = (Math.random() - 0.5) * 3;
                        dot.isCaught = false;
                        dot.caughtBy = null;
                        dot.passagewayProgress = 0;
                    }
                }
            });
            
            // Update cell health
            cells.forEach((cell, index) => {
                if (cell.isAlive) {
                    const timeSinceLastFed = currentTime - cell.lastFedTime;
                    const healthDecayRate = mitts[index].passagewaySpeed * 10;
                    
                    if (timeSinceLastFed < 1.5) {
                        cell.health = Math.min(100, cell.health + 1);
                    } else {
                        cell.health = Math.max(0, cell.health - healthDecayRate);
                    }
                    
                    if (cell.health <= 0) {
                        cell.isAlive = false;
                    }
                }
            });
        }
        
        // Draw everything - FIXED DRAWING ORDER
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw top section background FIRST (background)
            ctx.fillStyle = '#e8f4f8';
            ctx.fillRect(0, 0, canvas.width, topSectionHeight);
            
            // Draw dividing line
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, topSectionHeight);
            ctx.lineTo(canvas.width, topSectionHeight);
            ctx.stroke();
            
            // Draw mitts and passageways SECOND (static elements)
            mitts.forEach((mitt, index) => {
                // Draw mitt with solid color texture
                ctx.fillStyle = mitt.texture;
                ctx.fillRect(mitt.x, mitt.y, mitt.width, mitt.height);
                
                // Draw mitt outline
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(mitt.x, mitt.y, mitt.width, mitt.height);
                
                // Draw passageway with solid color matching mitt
                const hue = 240 - (mitt.stickiness * 120);
                const saturation = 70 + (mitt.stickiness * 30);
                const lightness = 50 - (mitt.stickiness * 10);
                
                ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                ctx.fillRect(mitt.x + mitt.width/2 - 10, mitt.y + mitt.height, 20, passagewayHeight);
            });
            
            // Draw cells THIRD
            cells.forEach(cell => {
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, cell.radius, 0, Math.PI * 2);
                
                if (!cell.isAlive) {
                    ctx.fillStyle = '#000000';
                } else if (cell.health > 70) {
                    ctx.fillStyle = '#4caf50';
                } else if (cell.health > 30) {
                    ctx.fillStyle = '#ffeb3b';
                } else {
                    ctx.fillStyle = '#f44336';
                }
                
                ctx.fill();
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(cell.health) + '%', cell.x, cell.y + 4);
            });
            
            // Draw dots LAST (they should appear on top)
            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
                
                if (dot.isCaught && dot.inPassageway) {
                    // Yellow for dots moving through passageway
                    ctx.fillStyle = '#ffeb3b';
                } else if (dot.isCaught) {
                    // Orange for dots caught by mitt (before entering passageway)
                    ctx.fillStyle = '#ff9800';
                } else {
                    // Green for free-floating dots
                    ctx.fillStyle = '#4caf50';
                }
                
                ctx.fill();
            });
            
            // Draw dots in passageways separately to ensure they're visible
            mitts.forEach((mitt, index) => {
                dots.forEach(dot => {
                    if (dot.caughtBy === index && dot.inPassageway) {
                        const passagewayYPos = mitt.y + mitt.height + dot.passagewayProgress * passagewayHeight;
                        ctx.beginPath();
                        ctx.arc(mitt.x + mitt.width/2, passagewayYPos, dot.radius, 0, Math.PI * 2);
                        ctx.fillStyle = '#ffeb3b';
                        ctx.fill();
                        
                        // Add a subtle glow to make passageway dots more visible
                        ctx.strokeStyle = 'rgba(255, 235, 59, 0.5)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });
            });
            
            // Draw stickiness labels UNDERNEATH cells
            mitts.forEach((mitt, index) => {
                const cell = cells[index];
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Stickiness: ${mitt.stickiness.toFixed(2)}`, 
                           cell.x, cell.y + cellRadius + 20);
            });
            
            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Enzyme Mitts (Extreme stickiness gradient →)', canvas.width/2, topSectionHeight - 10);
            ctx.fillText('Cells', canvas.width/2, 480);
            
            // Debug: Show current dot counts on mitts
            mitts.forEach((mitt, index) => {
                ctx.fillStyle = '#000';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Dots: ${mitt.caughtDots}`, mitt.x + mitt.width/2, mitt.y - 15);
            });
        }
        
        // Initialize and draw first frame
        initSimulation();
        draw();
    </script>
</body>
</html>
