<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Michaelis-Menten Kinetics Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #333;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 0 auto;
            background-color: #ffffff;
        }
        
        button {
            padding: 8px 15px;
            margin: 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button.stop {
            background-color: #f44336;
        }
        
        button.stop:hover {
            background-color: #d32f2f;
        }
        
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .stats-table th, .stats-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .stats-table th {
            background-color: #f2f2f2;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
        }
        
        .slider-value {
            margin-left: 10px;
            min-width: 30px;
        }
        
        #dotCount {
            width: 200px;
        }
        
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Michaelis-Menten Kinetics Simulation</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="dotCount">Substrate Concentration (dots):</label>
                <div class="slider-container">
                    <input type="range" id="dotCount" min="10" max="200" value="50">
                    <span id="dotCountValue" class="slider-value">50</span>
                </div>
            </div>
            
            <div class="control-group">
                <button id="startBtn">Start</button>
                <button id="stopBtn" class="stop">Stop</button>
                <button id="resetBtn">Reset</button>
            </div>
        </div>
        
        <canvas id="simulationCanvas" width="800" height="600"></canvas>
        
        <div class="explanation">
            <h3>How Stickiness Works:</h3>
            <p><strong>Stickiness = Catch Probability × Passageway Slowness</strong></p>
            <p>• <strong>High Stickiness (Blue Mitts):</strong> 90% catch rate, but very slow metabolism (3x slower)</p>
            <p>• <strong>Medium Stickiness:</strong> 50% catch rate, moderate metabolism speed</p>
            <p>• <strong>Low Stickiness (Red Mitts):</strong> 10% catch rate, but fast metabolism (3x faster)</p>
            <p>This represents the Michaelis-Menten tradeoff: stronger binding (high stickiness) means better substrate capture at low concentrations but slower catalytic turnover.</p>
        </div>
        
        <table id="statsTable" class="stats-table" style="display: none;">
            <thead>
                <tr>
                    <th>Enzyme Mitt</th>
                    <th>Stickiness</th>
                    <th>Catch Rate</th>
                    <th>Time Survived (s)</th>
                    <th>Dots Metabolized</th>
                </tr>
            </thead>
            <tbody id="statsBody">
                <!-- Stats will be populated here -->
            </tbody>
        </table>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        
        // Control elements
        const dotCountSlider = document.getElementById('dotCount');
        const dotCountValue = document.getElementById('dotCountValue');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const statsTable = document.getElementById('statsTable');
        const statsBody = document.getElementById('statsBody');
        
        // Simulation parameters
        const numMitts = 4;
        const mittWidth = 60;
        const mittHeight = 40;
        const passagewayHeight = 80;
        const cellRadius = 30;
        const dotRadius = 5;
        const topSectionHeight = 150; // Dots should stay above this line
        
        // Simulation state
        let dots = [];
        let mitts = [];
        let cells = [];
        let animationId = null;
        let isRunning = false;
        let startTime = null;
        let currentTime = 0;
        
        // Create texture gradient for mitts
        function createMittTexture(stickiness) {
            // Create a canvas for the texture pattern
            const textureCanvas = document.createElement('canvas');
            textureCanvas.width = 20;
            textureCanvas.height = 20;
            const textureCtx = textureCanvas.getContext('2d');
            
            // Blue gradient based on stickiness (darker blue = stickier)
            const hue = 240 - (stickiness * 120); // Blue (240) to Blue-Cyan (120)
            const saturation = 70 + (stickiness * 30); // More saturated for stickier mitts
            const lightness = 50 - (stickiness * 10); // Darker for stickier mitts
            
            // Base color
            textureCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            textureCtx.fillRect(0, 0, 20, 20);
            
            // Add texture pattern (diamond/weave pattern)
            textureCtx.strokeStyle = `hsl(${hue}, ${saturation}%, ${lightness - 15}%)`;
            textureCtx.lineWidth = 1;
            
            // Diamond pattern
            for (let i = 0; i < 20; i += 5) {
                for (let j = 0; j < 20; j += 5) {
                    textureCtx.beginPath();
                    textureCtx.moveTo(i, j);
                    textureCtx.lineTo(i + 5, j + 5);
                    textureCtx.stroke();
                }
            }
            
            return ctx.createPattern(textureCanvas, 'repeat');
        }
        
        // Initialize the simulation
        function initSimulation() {
            dots = [];
            mitts = [];
            cells = [];
            currentTime = 0;
            
            // Create mitts with EXTREME differences in stickiness (left to right)
            const mittSpacing = (canvas.width - numMitts * mittWidth) / (numMitts + 1);
            for (let i = 0; i < numMitts; i++) {
                const x = mittSpacing + i * (mittWidth + mittSpacing);
                const y = topSectionHeight; // Fixed Y position at the boundary
                
                // EXTREME stickiness differences (0.1 to 0.9)
                const stickiness = 0.1 + (i * 0.8 / (numMitts - 1));
                
                mitts.push({
                    x: x,
                    y: y,
                    width: mittWidth,
                    height: mittHeight,
                    stickiness: stickiness,
                    catchProbability: 0.1 + (stickiness * 0.8), // 10% to 90% catch rate
                    passagewaySpeed: 0.02 / (0.5 + stickiness * 0.5), // Slower for stickier mitts
                    caughtDots: 0,
                    startTime: null,
                    timeSurvived: 0,
                    texture: createMittTexture(stickiness)
                });
                
                // Create corresponding cells beneath each mitt
                cells.push({
                    x: x + mittWidth/2,
                    y: y + mittHeight + passagewayHeight + cellRadius,
                    radius: cellRadius,
                    health: 100, // 0-100 scale
                    lastFedTime: 0,
                    isAlive: true
                });
            }
            
            // Create initial dots
            createDots(dotCountSlider.value);
            
            // Reset stats table
            statsTable.style.display = 'none';
            statsBody.innerHTML = '';
        }
        
        // Create dots based on current count
        function createDots(count) {
            dots = [];
            for (let i = 0; i < count; i++) {
                dots.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (topSectionHeight - 20) + 10, // Only in top section
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    radius: dotRadius,
                    isCaught: false,
                    caughtBy: null,
                    inPassageway: false,
                    passagewayProgress: 0
                });
            }
        }
        
        // Update dot count display
        dotCountSlider.addEventListener('input', function() {
            dotCountValue.textContent = this.value;
            if (isRunning) {
                const currentCount = dots.length;
                const targetCount = parseInt(this.value);
                
                if (targetCount > currentCount) {
                    // Add more dots
                    for (let i = currentCount; i < targetCount; i++) {
                        dots.push({
                            x: Math.random() * canvas.width,
                            y: Math.random() * (topSectionHeight - 20) + 10,
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3,
                            radius: dotRadius,
                            isCaught: false,
                            caughtBy: null,
                            inPassageway: false,
                            passagewayProgress: 0
                        });
                    }
                } else if (targetCount < currentCount) {
                    // Remove excess dots
                    dots = dots.filter(dot => dot.isCaught || dot.inPassageway).concat(
                        dots.filter(dot => !dot.isCaught && !dot.inPassageway)
                            .slice(0, Math.max(0, targetCount - dots.filter(dot => dot.isCaught || dot.inPassageway).length))
                    );
                }
            }
        });
        
        // Start simulation
        startBtn.addEventListener('click', function() {
            if (!isRunning) {
                isRunning = true;
                startTime = Date.now();
                
                // Initialize start times for mitts that haven't started yet
                mitts.forEach(mitt => {
                    if (mitt.startTime === null) {
                        mitt.startTime = startTime;
                    }
                });
                
                animate();
            }
        });
        
        // Stop simulation
        stopBtn.addEventListener('click', function() {
            if (isRunning) {
                isRunning = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                
                // Calculate and display stats
                displayStats();
            }
        });
        
        // Reset simulation
        resetBtn.addEventListener('click', function() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            isRunning = false;
            initSimulation();
            draw();
        });
        
        // Display stats table
        function displayStats() {
            statsTable.style.display = 'table';
            statsBody.innerHTML = '';
            
            mitts.forEach((mitt, index) => {
                const row = document.createElement('tr');
                
                const mittCell = document.createElement('td');
                mittCell.textContent = `Enzyme ${index + 1}`;
                
                const stickinessCell = document.createElement('td');
                stickinessCell.textContent = mitt.stickiness.toFixed(2);
                
                const catchRateCell = document.createElement('td');
                catchRateCell.textContent = `${(mitt.catchProbability * 100).toFixed(0)}%`;
                
                const timeCell = document.createElement('td');
                if (mitt.startTime) {
                    const timeSurvived = (Date.now() - mitt.startTime) / 1000;
                    timeCell.textContent = timeSurvived.toFixed(2);
                    mitt.timeSurvived = timeSurvived;
                } else {
                    timeCell.textContent = "0.00";
                }
                
                const dotsCell = document.createElement('td');
                dotsCell.textContent = mitt.caughtDots;
                
                row.appendChild(mittCell);
                row.appendChild(stickinessCell);
                row.appendChild(catchRateCell);
                row.appendChild(timeCell);
                row.appendChild(dotsCell);
                
                statsBody.appendChild(row);
            });
        }
        
        // Main animation loop
        function animate() {
            if (!isRunning) return;
            
            currentTime = (Date.now() - startTime) / 1000;
            update();
            draw();
            animationId = requestAnimationFrame(animate);
        }
        
        // Update simulation state
        function update() {
            // Update dots - KEEP THEM IN TOP SECTION
            dots.forEach(dot => {
                if (!dot.isCaught && !dot.inPassageway) {
                    // Move dot
                    dot.x += dot.vx;
                    dot.y += dot.vy;
                    
                    // Boundary checks - KEEP IN TOP SECTION
                    if (dot.x < dot.radius || dot.x > canvas.width - dot.radius) {
                        dot.vx = -dot.vx;
                        dot.x = Math.max(dot.radius, Math.min(canvas.width - dot.radius, dot.x));
                    }
                    
                    // IMPORTANT: Keep dots in top section!
                    if (dot.y < dot.radius) {
                        dot.vy = -dot.vy;
                        dot.y = dot.radius;
                    }
                    
                    // Prevent dots from going below the mitt line unless caught
                    if (dot.y > topSectionHeight - dot.radius) {
                        dot.vy = -Math.abs(dot.vy); // Bounce upward
                        dot.y = topSectionHeight - dot.radius;
                    }
                    
                    // Check if dot is caught by a mitt
                    mitts.forEach((mitt, index) => {
                        if (!dot.isCaught && !dot.inPassageway &&
                            dot.x > mitt.x && dot.x < mitt.x + mitt.width &&
                            dot.y + dot.radius > mitt.y && dot.y < mitt.y + mitt.height) {
                            
                            // Probability of catching based on EXTREME differences
                            if (Math.random() < mitt.catchProbability) {
                                dot.isCaught = true;
                                dot.caughtBy = index;
                                dot.inPassageway = true;
                                mitt.caughtDots++;
                                
                                // Update cell last fed time
                                if (cells[index].isAlive) {
                                    cells[index].lastFedTime = currentTime;
                                }
                            }
                        }
                    });
                } else if (dot.inPassageway) {
                    // Move dot through passageway - SPEED VARIES DRAMATICALLY
                    const mittIndex = dot.caughtBy;
                    const mitt = mitts[mittIndex];
                    
                    // Progress based on extreme speed differences
                    dot.passagewayProgress += mitt.passagewaySpeed;
                    
                    if (dot.passagewayProgress >= 1) {
                        // Dot reached the cell
                        dot.inPassageway = false;
                        
                        // Respawn dot at top
                        dot.x = Math.random() * canvas.width;
                        dot.y = Math.random() * (topSectionHeight - 40) + 20;
                        dot.vx = (Math.random() - 0.5) * 3;
                        dot.vy = (Math.random() - 0.5) * 3;
                        dot.isCaught = false;
                        dot.caughtBy = null;
                        dot.passagewayProgress = 0;
                    }
                }
            });
            
            // Update cell health
            cells.forEach((cell, index) => {
                if (cell.isAlive) {
                    const timeSinceLastFed = currentTime - cell.lastFedTime;
                    
                    // Health decreases faster for cells with slower metabolism
                    const healthDecayRate = mitts[index].passagewaySpeed * 10; // Faster decay for slower enzymes
                    
                    if (timeSinceLastFed < 1.5) {
                        // Recently fed - health increases quickly
                        cell.health = Math.min(100, cell.health + 1);
                    } else {
                        // Not fed recently - health decreases
                        cell.health = Math.max(0, cell.health - healthDecayRate);
                    }
                    
                    // Check if cell dies
                    if (cell.health <= 0) {
                        cell.isAlive = false;
                    }
                }
            });
        }
        
        // Draw everything
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw top section background
            ctx.fillStyle = '#e8f4f8';
            ctx.fillRect(0, 0, canvas.width, topSectionHeight);
            
            // Draw dividing line between top and bottom sections
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, topSectionHeight);
            ctx.lineTo(canvas.width, topSectionHeight);
            ctx.stroke();
            
            // Draw dots
            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
                
                if (dot.isCaught && dot.inPassageway) {
                    // Dot in passageway - yellow
                    ctx.fillStyle = '#ffeb3b';
                } else if (dot.isCaught) {
                    // Dot caught by mitt - orange
                    ctx.fillStyle = '#ff9800';
                } else {
                    // Free dot - green
                    ctx.fillStyle = '#4caf50';
                }
                
                ctx.fill();
            });
            
            // Draw mitts and passageways with texture gradient
            mitts.forEach((mitt, index) => {
                // Draw mitt with texture
                ctx.fillStyle = mitt.texture;
                ctx.fillRect(mitt.x, mitt.y, mitt.width, mitt.height);
                
                // Draw mitt outline
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(mitt.x, mitt.y, mitt.width, mitt.height);
                
                // Draw passageway with gradient matching the mitt
                const gradient = ctx.createLinearGradient(
                    mitt.x + mitt.width/2 - 10, mitt.y + mitt.height,
                    mitt.x + mitt.width/2 - 10, mitt.y + mitt.height + passagewayHeight
                );
                
                const hue = 240 - (mitt.stickiness * 120);
                const saturation = 70 + (mitt.stickiness * 30);
                gradient.addColorStop(0, `hsl(${hue}, ${saturation}%, 50%)`);
                gradient.addColorStop(1, `hsl(${hue}, ${saturation}%, 30%)`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(mitt.x + mitt.width/2 - 10, mitt.y + mitt.height, 20, passagewayHeight);
                
                // Draw dots in passageway
                dots.forEach(dot => {
                    if (dot.caughtBy === index && dot.inPassageway) {
                        const passagewayYPos = mitt.y + mitt.height + dot.passagewayProgress * passagewayHeight;
                        ctx.beginPath();
                        ctx.arc(mitt.x + mitt.width/2, passagewayYPos, dot.radius, 0, Math.PI * 2);
                        ctx.fillStyle = '#ffeb3b';
                        ctx.fill();
                    }
                });
                
                // Draw stickiness label
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${(mitt.catchProbability * 100).toFixed(0)}%`, mitt.x + mitt.width/2, mitt.y - 5);
            });
            
            // Draw cells with health-based colors
            cells.forEach(cell => {
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, cell.radius, 0, Math.PI * 2);
                
                // Color based on health
                if (!cell.isAlive) {
                    ctx.fillStyle = '#000000'; // Dead - black
                } else if (cell.health > 70) {
                    ctx.fillStyle = '#4caf50'; // Healthy - green
                } else if (cell.health > 30) {
                    ctx.fillStyle = '#ffeb3b'; // Warning - yellow
                } else {
                    ctx.fillStyle = '#f44336'; // Danger - red
                }
                
                ctx.fill();
                
                // Draw cell outline
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw health indicator
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(cell.health) + '%', cell.x, cell.y + 4);
            });
            
            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Substrate Area (Dots stay here unless caught)', canvas.width/2, 20);
            ctx.fillText('Enzyme Mitts (Extreme stickiness gradient →)', canvas.width/2, topSectionHeight - 10);
            ctx.fillText('Cells', canvas.width/2, 500);
        }
        
        // Initialize and draw first frame
        initSimulation();
        draw();
    </script>
</body>
</html>
