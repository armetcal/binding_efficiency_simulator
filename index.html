<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Michaelis-Menten Kinetics Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #333;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 0 auto;
            background-color: #ffffff;
        }
        
        button {
            padding: 8px 15px;
            margin: 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button.stop {
            background-color: #f44336;
        }
        
        button.stop:hover {
            background-color: #d32f2f;
        }
        
        button.reset {
            background-color: #3662f4;
        }
        
        button.reset:hover {
            background-color: #3662f4;
        }
        
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .stats-table th, .stats-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .stats-table th {
            background-color: #f2f2f2;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
        }
        
        .slider-value {
            margin-left: 10px;
            min-width: 30px;
        }
        
        #dotCount {
            width: 200px;
        }
        
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Michaelis-Menten Kinetics Simulation</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="dotCount">Substrate Concentration (dots):</label>
                <div class="slider-container">
                    <input type="range" id="dotCount" min="10" max="200" value="50">
                    <span id="dotCountValue" class="slider-value">50</span>
                </div>
            </div>
            
            <div class="control-group">
                <button id="startBtn">Start</button>
                <button id="stopBtn" class="stop">Stop</button>
                <button id="resetBtn" class="reset">Reset</button>
            </div>
        </div>
        
        <canvas id="simulationCanvas" width="800" height="550"></canvas>
        
        <div class="explanation">
            <h3>How Stickiness Works:</h3>
            <p><strong>Stickiness = Catch Probability × Passageway Slowness</strong></p>
            <p>• <strong>High Stickiness (Super Glue):</strong> 90% catch rate, but very slow metabolism</p>
            <p>• <strong>Medium Stickiness (Hot Glue):</strong> 50% catch rate, moderate metabolism speed</p>
            <p>• <strong>Low Stickiness (Kid's Glue):</strong> 10% catch rate, but fast metabolism</p>
            <p>When a dot touches a mitt: Success = dot gets caught and goes down passageway. Failure = dot bounces off like a wall.</p>
            <p><strong>Note:</strong> Each enzyme can only process one substrate at a time!</p>
        </div>
        
        <table id="statsTable" class="stats-table" style="display: none;">
            <thead>
                <tr>
                    <th>Enzyme Mitt</th>
                    <th>Catch Rate</th>
                    <th>Time Survived (s)</th>
                    <th>Total Dots Metabolized</th>
                </tr>
            </thead>
            <tbody id="statsBody">
                <!-- Stats will be populated here -->
            </tbody>
        </table>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        
        // Control elements
        const dotCountSlider = document.getElementById('dotCount');
        const dotCountValue = document.getElementById('dotCountValue');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const statsTable = document.getElementById('statsTable');
        const statsBody = document.getElementById('statsBody');
        
        // Simulation parameters
        const numMitts = 4;
        const mittWidth = 60;
        const mittHeight = 40;
        const passagewayHeight = 180;
        const cellRadius = 30;
        const dotRadius = 6;
        const topSectionHeight = 150;
        
        // Simulation state
        let dots = [];
        let mitts = [];
        let cells = [];
        let animationId = null;
        let isRunning = false;
        let startTime = null;
        let currentTime = 0;
        
        // Create glue icons for different stickiness levels
        function createGlueIcon(stickiness) {
            const iconCanvas = document.createElement('canvas');
            iconCanvas.width = 50;
            iconCanvas.height = 50;
            const iconCtx = iconCanvas.getContext('2d');
            
            iconCtx.fillStyle = '#f0f0f0';
            iconCtx.fillRect(0, 0, 50, 50);
            
            // Different glue types based on stickiness
            if (stickiness <= 0.25) {
                // Kids glue (white/yellow)
                iconCtx.fillStyle = '#ffffcc';
                iconCtx.fillRect(10, 15, 30, 25);
                iconCtx.strokeStyle = '#666';
                iconCtx.lineWidth = 2;
                iconCtx.strokeRect(10, 15, 30, 25);
                iconCtx.fillStyle = '#666';
                iconCtx.font = '8px Arial';
                iconCtx.fillText('Kids', 15, 30);
                iconCtx.fillText('Glue', 15, 40);
            } else if (stickiness <= 0.5) {
                // School glue (light blue)
                iconCtx.fillStyle = '#b3e0ff';
                iconCtx.fillRect(10, 15, 30, 25);
                iconCtx.strokeStyle = '#0066cc';
                iconCtx.lineWidth = 2;
                iconCtx.strokeRect(10, 15, 30, 25);
                iconCtx.fillStyle = '#0066cc';
                iconCtx.font = '8px Arial';
                iconCtx.fillText('School', 12, 30);
                iconCtx.fillText('Glue', 15, 40);
            } else if (stickiness <= 0.75) {
                // Hot glue (orange)
                iconCtx.fillStyle = '#ffcc99';
                iconCtx.fillRect(10, 15, 30, 25);
                iconCtx.strokeStyle = '#ff6600';
                iconCtx.lineWidth = 2;
                iconCtx.strokeRect(10, 15, 30, 25);
                iconCtx.fillStyle = '#ff6600';
                iconCtx.font = '8px Arial';
                iconCtx.fillText('Hot', 18, 30);
                iconCtx.fillText('Glue', 18, 40);
            } else {
                // Super glue (red)
                iconCtx.fillStyle = '#ff9999';
                iconCtx.fillRect(10, 15, 30, 25);
                iconCtx.strokeStyle = '#cc0000';
                iconCtx.lineWidth = 2;
                iconCtx.strokeRect(10, 15, 30, 25);
                iconCtx.fillStyle = '#cc0000';
                iconCtx.font = '8px Arial';
                iconCtx.fillText('Super', 15, 30);
                iconCtx.fillText('Glue', 18, 40);
            }
            
            return iconCanvas;
        }
        
        // Create texture gradient for mitts
        function createMittTexture(stickiness) {
            const textureCanvas = document.createElement('canvas');
            textureCanvas.width = 20;
            textureCanvas.height = 20;
            const textureCtx = textureCanvas.getContext('2d');
            
            // Blue to white gradient
            const blueIntensity = Math.floor(stickiness * 200);
            const redGreen = Math.floor(255 - (stickiness * 100));
            
            textureCtx.fillStyle = `rgb(${redGreen}, ${redGreen}, 255)`;
            textureCtx.fillRect(0, 0, 20, 20);
            
            return ctx.createPattern(textureCanvas, 'repeat');
        }
        
        // Initialize the simulation
        function initSimulation() {
            dots = [];
            mitts = [];
            cells = [];
            currentTime = 0;
            
            // Create mitts with EXTREME differences in stickiness (left to right)
            const mittSpacing = (canvas.width - numMitts * mittWidth) / (numMitts + 1);
            for (let i = 0; i < numMitts; i++) {
                const x = mittSpacing + i * (mittWidth + mittSpacing);
                const y = topSectionHeight;
                
                // EXTREME stickiness differences (0.1 to 0.9)
                const stickiness = 0.25 + (i * 0.75 / (numMitts - 1));
                
                mitts.push({
                    x: x,
                    y: y,
                    width: mittWidth,
                    height: mittHeight,
                    stickiness: stickiness,
                    catchProbability: stickiness,
                    passagewaySpeed: 0.04 / (10 * Math.pow(stickiness, 2)),
                    caughtDots: 0,
                    totalDotsMetabolized: 0,
                    startTime: null,
                    deathTime: null,
                    timeSurvived: 0,
                    isAvailable: true,
                    texture: createMittTexture(stickiness),
                    glueIcon: createGlueIcon(stickiness)
                });
                
                // Create corresponding cells beneath each mitt
                cells.push({
                    x: x + mittWidth/2,
                    y: y + mittHeight + passagewayHeight + cellRadius,
                    radius: cellRadius,
                    health: 100,
                    lastFedTime: 0,
                    isAlive: true
                });
            }
            
            // Create initial dots
            createDots(dotCountSlider.value);
            
            // Reset stats table
            statsTable.style.display = 'none';
            statsBody.innerHTML = '';
        }
        
        // Create dots based on current count
        function createDots(count) {
            dots = [];
            for (let i = 0; i < count; i++) {
                dots.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (topSectionHeight - 20) + 10,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    radius: dotRadius,
                    isCaught: false,
                    caughtBy: null,
                    inPassageway: false,
                    passagewayProgress: 0
                });
            }
            
            // Update dot count display in real-time
            dotCountValue.textContent = count;
        }
        
        // Update dot count display - REAL-TIME UPDATES
        dotCountSlider.addEventListener('input', function() {
            const targetCount = parseInt(this.value);
            
            if (!isRunning) {
                // If not running, just update display
                dotCountValue.textContent = targetCount;
                return;
            }
            
            // Real-time updates while running
            const currentCount = dots.length;
            
            if (targetCount > currentCount) {
                // Add more dots
                const dotsToAdd = targetCount - currentCount;
                for (let i = 0; i < dotsToAdd; i++) {
                    dots.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * (topSectionHeight - 20) + 10,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        radius: dotRadius,
                        isCaught: false,
                        caughtBy: null,
                        inPassageway: false,
                        passagewayProgress: 0
                    });
                }
            } else if (targetCount < currentCount) {
                // Remove excess dots (remove uncaptured ones first)
                const dotsToKeep = targetCount;
                const capturedDots = dots.filter(dot => dot.isCaught || dot.inPassageway);
                const freeDots = dots.filter(dot => !dot.isCaught && !dot.inPassageway);
                
                // Keep all captured dots + needed free dots
                dots = capturedDots.concat(freeDots.slice(0, Math.max(0, dotsToKeep - capturedDots.length)));
            }
            
            dotCountValue.textContent = targetCount;
        });
        
        // Start simulation
        startBtn.addEventListener('click', function() {
            if (!isRunning) {
                isRunning = true;
                startTime = Date.now();
                
                mitts.forEach(mitt => {
                    if (mitt.startTime === null) {
                        mitt.startTime = startTime;
                        mitt.deathTime = null;
                        mitt.totalDotsMetabolized = 0;
                        mitt.isAvailable = true;
                    }
                });
                
                cells.forEach(cell => {
                    cell.lastFedTime = 0;
                });
                
                animate();
            }
        });
        
        // Stop simulation
        stopBtn.addEventListener('click', function() {
            if (isRunning) {
                isRunning = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                displayStats();
            }
        });
        
        // Reset simulation
        resetBtn.addEventListener('click', function() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            isRunning = false;
            initSimulation();
            draw();
        });
        
        // Display stats table
        function displayStats() {
            statsTable.style.display = 'table';
            statsBody.innerHTML = '';
            
            mitts.forEach((mitt, index) => {
                const row = document.createElement('tr');
                const cell = cells[index];
                
                const mittCell = document.createElement('td');
                mittCell.textContent = `Enzyme ${index + 1}`;
                
                const catchRateCell = document.createElement('td');
                catchRateCell.textContent = `${(mitt.catchProbability * 100).toFixed(0)}%`;
                
                const timeCell = document.createElement('td');
                if (mitt.startTime) {
                    const endTime = cell.isAlive ? Date.now() : mitt.deathTime;
                    const timeSurvived = (endTime - mitt.startTime) / 1000;
                    timeCell.textContent = timeSurvived.toFixed(2);
                    mitt.timeSurvived = timeSurvived;
                } else {
                    timeCell.textContent = "0.00";
                }
                
                const dotsCell = document.createElement('td');
                dotsCell.textContent = mitt.totalDotsMetabolized;
                
                row.appendChild(mittCell);
                row.appendChild(catchRateCell);
                row.appendChild(timeCell);
                row.appendChild(dotsCell);
                
                statsBody.appendChild(row);
            });
        }
        
        // Main animation loop
        function animate() {
            if (!isRunning) return;
            
            currentTime = (Date.now() - startTime) / 1000;
            update();
            draw();
            animationId = requestAnimationFrame(animate);
        }
        
        // Update simulation state - FIXED: Same decay rate for all cells
        function update() {
            // Update dots
            dots.forEach(dot => {
                if (!dot.isCaught && !dot.inPassageway) {
                    dot.x += dot.vx;
                    dot.y += dot.vy;
                    
                    // Boundary checks
                    if (dot.x < dot.radius || dot.x > canvas.width - dot.radius) {
                        dot.vx = -dot.vx;
                        dot.x = Math.max(dot.radius, Math.min(canvas.width - dot.radius, dot.x));
                    }
                    
                    if (dot.y < dot.radius) {
                        dot.vy = -dot.vy;
                        dot.y = dot.radius;
                    }
                    
                    let mittCollision = false;
                    
                    for (let i = 0; i < mitts.length && !mittCollision; i++) {
                        const mitt = mitts[i];
                        const cell = cells[i];
                        
                        // Only process mitts with living cells AND available enzymes
                        if (!cell.isAlive || !mitt.isAvailable) continue;
                        
                        if (dot.x + dot.radius > mitt.x && dot.x - dot.radius < mitt.x + mitt.width &&
                            dot.y + dot.radius > mitt.y && dot.y - dot.radius < mitt.y + mitt.height) {
                            
                            mittCollision = true;
                            
                            if (Math.random() < mitt.catchProbability) {
                                // Dot gets caught - enzyme becomes busy
                                dot.isCaught = true;
                                dot.caughtBy = i;
                                dot.inPassageway = true;
                                mitt.caughtDots++;
                                mitt.isAvailable = false;
                                
                                dot.x = mitt.x + mitt.width / 2;
                                dot.y = mitt.y + mitt.height;
                            } else {
                                // Dot bounces off
                                const mittCenterX = mitt.x + mitt.width / 2;
                                const mittCenterY = mitt.y + mitt.height / 2;
                                
                                if (Math.abs(dot.x - mittCenterX) > Math.abs(dot.y - mittCenterY)) {
                                    dot.vx = -dot.vx;
                                    dot.x = dot.vx > 0 ? mitt.x + mitt.width + dot.radius : mitt.x - dot.radius;
                                } else {
                                    dot.vy = -dot.vy;
                                    dot.y = dot.vy > 0 ? mitt.y + mitt.height + dot.radius : mitt.y - dot.radius;
                                }
                            }
                        }
                    }
                    
                    if (!mittCollision && dot.y > topSectionHeight - dot.radius) {
                        dot.vy = -Math.abs(dot.vy);
                        dot.y = topSectionHeight - dot.radius;
                    }
                    
                } else if (dot.inPassageway) {
                    const mittIndex = dot.caughtBy;
                    const mitt = mitts[mittIndex];
                    const cell = cells[mittIndex];
                    
                    dot.passagewayProgress += mitt.passagewaySpeed;
                    
                    if (dot.passagewayProgress >= 1) {
                        // Dot reached the cell - metabolism complete
                        dot.inPassageway = false;
                        mitt.totalDotsMetabolized++;
                        mitt.isAvailable = true;
                        
                        if (cell.isAlive) {
                            cell.lastFedTime = currentTime;
                        }
                        
                        dot.x = Math.random() * canvas.width;
                        dot.y = Math.random() * (topSectionHeight - 40) + 20;
                        dot.vx = (Math.random() - 0.5) * 3;
                        dot.vy = (Math.random() - 0.5) * 3;
                        dot.isCaught = false;
                        dot.caughtBy = null;
                        dot.passagewayProgress = 0;
                    }
                }
            });
            
            // Update cell health - FIXED: All cells decay at same rate
            cells.forEach((cell, index) => {
                const mitt = mitts[index];
                
                if (cell.isAlive) {
                    const timeSinceLastFed = currentTime - cell.lastFedTime;
                    const healthDecayRate = 0.15; // SAME RATE FOR ALL CELLS
                    
                    if (timeSinceLastFed < 1.5) {
                        cell.health = Math.min(100, cell.health + 0.5);
                    } else {
                        cell.health = Math.max(0, cell.health - healthDecayRate);
                    }
                    
                    if (cell.health <= 0) {
                        cell.isAlive = false;
                        mitt.isAvailable = false;
                        mitt.deathTime = Date.now();
                    }
                }
            });
        }
        
        // Draw everything
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw top section background
            ctx.fillStyle = '#e8f4f8';
            ctx.fillRect(0, 0, canvas.width, topSectionHeight);
            
            // Draw dividing line
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, topSectionHeight);
            ctx.lineTo(canvas.width, topSectionHeight);
            ctx.stroke();
            
            // Draw mitts and passageways with borders
            mitts.forEach((mitt, index) => {
                const cell = cells[index];
                
                // Only draw mitts for living cells
                if (cell.isAlive) {
                    // Different fill color for busy enzymes
                    if (mitt.isAvailable) {
                        ctx.fillStyle = mitt.texture;
                    } else {
                        // Busy enzyme - darker color
                        const blueIntensity = Math.floor(mitt.stickiness * 200);
                        const redGreen = Math.floor(200 - (mitt.stickiness * 100));
                        ctx.fillStyle = `rgb(${redGreen}, ${redGreen}, 200)`;
                    }
                    
                    ctx.fillRect(mitt.x, mitt.y, mitt.width, mitt.height);
                    
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(mitt.x, mitt.y, mitt.width, mitt.height);
                    
                    ctx.drawImage(mitt.glueIcon, mitt.x + mitt.width/2 - 25, mitt.y + mitt.height/2 - 25);
                    
                    // Show enzyme status
                    ctx.fillStyle = '#000';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(mitt.isAvailable ? 'Available' : 'Processing...', mitt.x + mitt.width/2, mitt.y - 10);
                }
                
                // Draw passageway (always visible)
                const blueIntensity = Math.floor(mitt.stickiness * 200);
                const redGreen = Math.floor(255 - (mitt.stickiness * 100));
                
                ctx.fillStyle = `rgb(${redGreen}, ${redGreen}, 255)`;
                ctx.fillRect(mitt.x + mitt.width/2 - 10, mitt.y + mitt.height, 20, passagewayHeight);
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(mitt.x + mitt.width/2 - 10, mitt.y + mitt.height, 20, passagewayHeight);
            });
            
            // Draw cells
            cells.forEach(cell => {
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, cell.radius, 0, Math.PI * 2);
                
                if (!cell.isAlive) {
                    ctx.fillStyle = '#000000';
                } else if (cell.health > 70) {
                    ctx.fillStyle = '#4caf50';
                } else if (cell.health > 30) {
                    ctx.fillStyle = '#ffeb3b';
                } else {
                    ctx.fillStyle = '#f44336';
                }
                
                ctx.fill();
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#fff';
                ctx.font = '15px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(cell.health) + '%', cell.x, cell.y + 4);
            });
            
            // Draw dots
            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
                
                if (dot.isCaught && dot.inPassageway) {
                    ctx.fillStyle = '#ffeb3b';
                } else if (dot.isCaught) {
                    ctx.fillStyle = '#ff9800';
                } else {
                    ctx.fillStyle = '#4caf50';
                }
                
                ctx.fill();
            });
            
            // Draw dots in passageways
            mitts.forEach((mitt, index) => {
                const cell = cells[index];
                
                // Only process dots for living cells
                if (cell.isAlive) {
                    dots.forEach(dot => {
                        if (dot.caughtBy === index && dot.inPassageway) {
                            const passagewayYPos = mitt.y + mitt.height + dot.passagewayProgress * passagewayHeight;
                            ctx.beginPath();
                            ctx.arc(mitt.x + mitt.width/2, passagewayYPos, dot.radius, 0, Math.PI * 2);
                            ctx.fillStyle = '#ffeb3b';
                            ctx.fill();
                            
                            ctx.strokeStyle = 'rgba(255, 235, 59, 0.5)';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    });
                }
            });
            
            // Draw stickiness labels
            mitts.forEach((mitt, index) => {
                const cell = cells[index];
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Stickiness: ${mitt.stickiness.toFixed(2)}`, 
                           cell.x, cell.y + cellRadius + 20);
                
                if (!cell.isAlive) {
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('DEAD', cell.x, cell.y + cellRadius + 40);
                }
            });
            
            // Draw label
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('(Extreme stickiness gradient →)', canvas.width/2, 480);
        }
        
        // Initialize and draw first frame
        initSimulation();
        draw();
    </script>
</body>
</html>
